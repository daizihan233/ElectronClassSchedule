let weekIndex = localStorage.getItem('weekIndex')
if (weekIndex === null) localStorage.setItem('weekIndex', '0')
weekIndex = Number(localStorage.getItem('weekIndex'))

let timeOffset = localStorage.getItem('timeOffset')
if (timeOffset === null) localStorage.setItem('timeOffset', '0')
timeOffset = Number(localStorage.getItem('timeOffset'))

let dayOffset = localStorage.getItem('dayOffset')
if (dayOffset === null) localStorage.setItem('dayOffset', '-1')
dayOffset = Number(localStorage.getItem('dayOffset'))

let setDayOffsetLastDay = localStorage.getItem('setDayOffsetLastDay')
if (setDayOffsetLastDay === null) localStorage.setItem('setDayOffsetLastDay', '-1')
setDayOffsetLastDay = Number(localStorage.getItem('setDayOffsetLastDay'))


function getCurrentEditedDate() {
    let d = new Date();
    d.setSeconds(d.getSeconds() + Number.parseInt(timeOffset))
    return d;
}

function getCurrentEditedDay(date) {
    if (Number.parseInt(dayOffset) === -1)
        return date.getDay();
    if (Number.parseInt(setDayOffsetLastDay) === new Date().getDay()) {
        return dayOffset;
    }
    localStorage.setItem('dayOffset', '-1')
    localStorage.setItem('setDayOffsetLastDay', '-1')
    dayOffset = -1
    setDayOffsetLastDay = -1
    return date.getDay();
}

function isBreakTime(startTime, endTime, currentTime) {
    // 这俩东西我也不知道原作者怎么想的，实现逻辑一模一样
    return isClassCurrent(startTime, endTime, currentTime)
}

// Generated by ChatGPT4
function getCurrentDaySchedule() {
    const date = getCurrentEditedDate();
    const dayOfWeek = getCurrentEditedDay(date); // 0 = Sunday, 1 = Monday, ...
    const weekNumber = weekIndex; // 当前周数
    const dailyClass = scheduleConfig.daily_class[dayOfWeek];
    if (!dailyClass) return [];
    return dailyClass.classList.map(subject => {
        if (Array.isArray(subject)) {
            return subject[weekNumber]; // 处理每周不同的课程
        }
        return subject;
    });
}

function isClassCurrent(startTime, endTime, currentTime) {
    const [startH, startM] = startTime.split(':').map(Number);
    const [endH, endM] = endTime.split(':').map(Number);
    const [currentH, currentM] = currentTime.split(':').map(Number);

    const startMinutes = startH * 60 + startM;
    const endMinutes = endH * 60 + endM;
    const currentMinutes = currentH * 60 + currentM;

    return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
}

function getCurrentTime() {
    const now = getCurrentEditedDate();
    return [
        now.getHours().toString().padStart(2, '0'),
        now.getMinutes().toString().padStart(2, '0'),
        now.getSeconds().toString().padStart(2, '0')
    ].join(':');
}

function setCurrentHighlightExternal(currentHighlight, index, type, fullName, endTime, currentTime, isEnd = false) {
        currentHighlight.index = index;
        currentHighlight.type = type;
        currentHighlight.fullName = fullName;
        currentHighlight.countdown = calculateCountdown(endTime, currentTime);
        currentHighlight.countdownText = formatCountdown(currentHighlight.countdown);
        if (isEnd) currentHighlight.isEnd = true;
    }

function getScheduleData() {
    const currentSchedule = getCurrentDaySchedule();
    const currentTime = getCurrentTime();
    const dayOfWeek = getCurrentEditedDay(getCurrentEditedDate());
    const timetable = scheduleConfig.daily_class[dayOfWeek].timetable;
    const dayTimetable = scheduleConfig.timetable[timetable];
    const divider = scheduleConfig.divider[timetable];
    let scheduleArray = [];
    let currentHighlight = { index: null, type: null, fullName: null, countdown: null, countdownText: null };

    const timeRanges = Object.keys(dayTimetable);

    const findUpcoming = (breakIndex, breakRange) => {
        // 选择接下来最近的一节课作为 upcoming（高亮位置用下一节课），
        // 但显示的文字应为当前课间/时段在 timetable 中配置的标签。
        let breakLabel = '';
        const curVal = dayTimetable[breakRange];
        if (typeof curVal !== 'number' && curVal) breakLabel = String(curVal);

        // 如果 timetable 没给当前时段配置标签，则尝试向后找第一个字符串标签做为显示
        if (!breakLabel) {
            for (let i = breakIndex; i < timeRanges.length; i++) {
                const v = dayTimetable[timeRanges[i]];
                if (typeof v !== 'number' && v) {
                    breakLabel = String(v);
                    break;
                }
            }
        }
        // 兜底课间标签
        if (!breakLabel) breakLabel = (scheduleConfig['break_label']) || '课间';

        // 选择下一节课用于定位 upcoming 的 index
        for (let i = breakIndex + 1; i < timeRanges.length; i++) {
            const nextTimeRange = timeRanges[i];
            const nextClassIndex = dayTimetable[nextTimeRange];
            if (typeof nextClassIndex === 'number') {
                // scheduleArray.length 指向下一节在列表中的位置
                setCurrentHighlightExternal(
                    currentHighlight,
                    scheduleArray.length,
                    'upcoming',
                    breakLabel, // 注意：显示当前课间/标签，而不是下一节课名
                    breakRange.split('-')[1],
                    currentTime
                );
                return true;
            }
        }
        // 没有后续课程：遵循 timetable 的字符串标签，而不是恒定“放学”
        // 1) 优先使用后续时段中出现的第一个字符串标签
        let followingLabel = '';
        for (let i = breakIndex + 1; i < timeRanges.length; i++) {
            const v = dayTimetable[timeRanges[i]];
            if (typeof v !== 'number' && v) {
                followingLabel = String(v);
                break;
            }
        }
        // 2) 若没有后续标签，则尝试用当前时段本身的标签（通常就是“放学”等）
        if (!followingLabel) {
            const curVal2 = dayTimetable[breakRange];
            if (typeof curVal2 !== 'number' && curVal2) followingLabel = String(curVal2);
        }
        // 3) 仍无则回退到 end_of_day_label 或默认"放学"
        const dismissalFallback = (scheduleConfig['end_of_day_label']) || '放学';
        const dismissalLabel = followingLabel || dismissalFallback;
        setCurrentHighlightExternal(
            currentHighlight,
            Math.max(0, currentSchedule.length - 1),
            'upcoming',
            dismissalLabel,
            breakRange.split('-')[1],
            currentTime,
            true
        );
        return false;
    }

    for (const [index, timeRange] of timeRanges.entries()) {
        const [startTime, endTime] = timeRange.split('-');
        const classIndex = dayTimetable[timeRange];

        if (typeof classIndex === 'number') {
            const subjectShortName = currentSchedule[classIndex];
            const subjectFullName = scheduleConfig.subject_name[subjectShortName];
            scheduleArray.push(subjectShortName);

            if (isClassCurrent(startTime, endTime, currentTime)) {
                setCurrentHighlightExternal(currentHighlight, scheduleArray.length - 1, 'current', subjectFullName, endTime, currentTime);
            }
        } else if (currentHighlight.index === null && isBreakTime(startTime, endTime, currentTime)) {
            // 课间：寻找下一节课
            findUpcoming(index, timeRange);
        } else if (currentHighlight.index === null && !dayTimetable[timeRange]) {
            currentHighlight.fullName = currentSchedule[classIndex];
        }
    }

    return { scheduleArray, currentHighlight, timetable, divider };
}


function calculateCountdown(targetTime, currentTime) {
    const [targetH, targetM] = targetTime.split(':').map(Number);
    const [currentH, currentM, currentS = '00'] = currentTime.split(':').map(Number);

    const targetTotalSeconds = targetH * 3600 + (targetM + 1) * 60;
    const currentTotalSeconds = currentH * 3600 + currentM * 60 + currentS;

    return targetTotalSeconds - currentTotalSeconds;
}

function formatCountdown(countdownSeconds) {
    const minutes = Math.floor(countdownSeconds / 60);
    const seconds = countdownSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
